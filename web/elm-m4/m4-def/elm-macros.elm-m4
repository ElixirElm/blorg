divert(-1)

define( <!APP_LOADER!>, <!--
import Html
import Html as App
import Material.Scheme

main: Program Never
main =
  App.program
    $1

mainView : Model -> Html.Html Msg
mainView model =
  view model
  |> Material.Scheme.top!>)

define( <!IMPORT_HTML!>, <!-- Import Html
import Html exposing (Html, text, p)
!>)

define( <!IMPORT_MATERIAL!>, <!-- Import Material
import Material
import Material.Button as Button
import Material.Grid exposing (grid, cell, size, Device(..), noSpacing)
import Material.Icon as Icon
import Material.List as Lists
import Material.Options as Options exposing (css, styled, div, span, img)
import Material.Table as Table
import Material.Textfield as Textfield
import Material.Typography as Typo!>)

define( <!IMPORT_JSON_DECODE!>, <!-- Import Json Decode
import Json.Decode as Decode exposing(Decoder)
import Json.Decode.Pipeline exposing (decode, required, optional, hardcoded)!>)

-- SUB_UPDATE_MSG msg
define( <!SUB_UPDATE_MSG!>, <!
    $1 act ->
      update_$1 act model!>
    --)

-- SUB_UPDATE_MSG_WITHOUT_EVENT msg
define( <!SUB_UPDATE_MSG_ADDING_EVENT!>, <!
    $1 act ->
      withEvent <| update_$1 act model!>
    --)

-- SUB_DEF_GET_SET msg, module, model.field
define( <!SUB_DEF_GET_SET_DECLARE!>, <!-- Auto generated declaration
get_$1 : Model -> Maybe $2.Model
set_$1 : $2.Model -> Model -> Model
!>)

define( <!SUB_DEF_GET_SET!>, <!-- Auto generated get/set_$1
get_$1 : Model -> Maybe $2.Model
get_$1 model = Just model.$3

set_$1 : $2.Model -> Model -> Model
set_$1 value model = { model | $3 = value }
!>)

define(<!SUB_ON_DEMAND_GET_SET!>, <!-- Auto generated get/set_$1
get_$1 : Model -> Maybe $2.Model
get_$1 model =
  case model.onDemand of
    $1Model mdl -> Just mdl
    _ -> Nothing
set_$1 : $2.Model -> Model -> Model
set_$1 value model =
  case model.onDemand of
    $1Model mdl ->
      { model | onDemand = $1Model value }
    _ -> model
!>)

define(<!SUB_ASSIGN_ON_DEMAND!>, <!
          let
            (subModel, subCmd) = $2.init $5
          in
            ( {model
              | onDemand = $1Model subModel
              , route = $4
              }
            , Cmd.map $1 subCmd
            , Nothing
            )
!>)

define( <!SUB_DEF_FOCUS!>, <!
Depreciated SUB_ DEF_ FOCUS
!>)

-- SUB_UPDATE_DEF msg, module, model.field
define( <!SUB_UPDATE_WITHOUT_EVENT!>, <!-- Auto generated update_$1
update_$1 : $2.Msg -> Model -> ( Model, Cmd Msg )
update_$1 act model =
  let
    (newValue, newCmd) = $2.update act (get_$1 model)
  in
    (model |> set_$1 newValue, Cmd.map $1 newCmd)!>)

-- SUB_UPDATE_EVENT_DEF msg, module, model.field
define( <!SUB_UPDATE_WITH_EVENT!>, <!-- Auto generated update_$1
--   Expects: updateOnEventFrom_$1 newEvent myModel
update_$1 : $2.Msg -> Model -> ( Model, Cmd Msg, Maybe Event )
update_$1 act model =
  let
    maybeOldValue = (get_$1 model)
    (myModel, myCmd, maybeNewEvent) = case maybeOldValue of
      Nothing ->
        (model, Cmd.none, Nothing)
      Just oldValue ->
        let
          (newValue, newCmd, wantedEvent)
            = $2.update act oldValue
        in
          ( model |> set_$1 newValue, Cmd.map $1 newCmd, wantedEvent)
  in
    case maybeNewEvent of
      Nothing ->
        (myModel, myCmd, Nothing)
      Just newEvent ->
        let
          (afterModel, afterCmd, afterEvent)
            = updateOnEventFrom_$1 newEvent myModel
        in
          (afterModel, Cmd.batch [myCmd, afterCmd], afterEvent)!>)

-- SUB_VIEW msg, module, field
define( <!SUB_VIEW!>, <!
            ( let maybeSub = get_$1 model
              in
                              case maybeSub of
                                Nothing -> text ""
                                Just sub ->
                                  Html.map $1 ($2.view sub)
            )
!>)


define( <!MDL_COUNTER!>, 0)
define( <!MDL_IDX!>,
  <!MDL_COUNTER define( <!MDL_COUNTER!>, incr(MDL_COUNTER))!>)

divert(0)dnl
